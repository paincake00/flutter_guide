
29.09 месяц. 19:00 3 часа пн ср пт
1 час тестовое задание 1 час интервью (вторник, 16:00 тз, 17:00 интервью)

 - теория: массив/динам. массив/ассоциативный массив (внутрянка), веб, SQL, http (tcp, udp), REST, SOLID, принципы ООП. 
- практика: литкод изи для лайвкода (больше SQL)

[https://www.digitalleague.ru/traineeships/directions](https://www.digitalleague.ru/traineeships/directions)



# ==Типы и структуры данных==

### Массивы

Массив - это упорядоченный набор значений (элементы массива) одного и того же типа, которые можно получить по индексу (целое число). Размер массива постоянен и задан изначально (в простейшем случае).

Чтение/запись по индексу: O(1) (`base_address + i * size_of_element`)

### Динамические массивы

Динамические массивы - массивы, размеры которых могут изменяться.

Число значений в массиве - length
Число мест для значений - capacity

Для него выделяется память с запасом. При переполнении копируется и добавляется новая емкость (capacity) в 2 раза больше. 

Удобен, если не знаем сколько будет элементов и надо использовать индекс.

### Гетерогенные массивы

Массив, значения в котором могут иметь разный тип данных. Их могут реализовывать через массив из указателей на значения (они уже могут быть разного типа, важен адрес)

### Связанный список

Связанный список - это структура данных, которая реализуется через создание объектов - узлов (Node), которые хранят данные и ссылку на следующий узел (односвязанный).

Удобен, если надо очень часто добавлять/удалять элементы в начале/конце (O(1)) (из середины - если есть указатель на узел).

На нем основаны: stack, queue, dequeue.

### Бинарное дерево поиска (BST)

**Бинарное дерево поиска** — это структура данных в виде дерева, где каждый узел содержит:
1. **Значение**
2. **Ссылку на левое поддерево** (`Left`)
3. **Ссылку на правое поддерево** (`Right`)
Каждое левый потомок меньше, а каждый правый - больше.

Когда нужны **быстрые вставка, удаление и поиск** в отсортированных данных (O(log n)).

### Ассоциативный массив

Ассоциативный массив - это структура данных, которая хранит пары "ключ-значение" (неупорядоченно).

Поддерживает операции: добавление пары, поиск и удаление по ключу (O(1) - в лучшем, O(n) - в худшем, когда много коллизий - плохая хэш-функция).

Реализация на основе динамического массива:
- Хеш-функция переводит ключ (любой тип) в хеш (число) `"cat" → hash("cat") = 12873645`
- Индекс для массива находится через деление хэша по модулю на размер массива:
  `index = hash("cat") % capacity`
- Элемент кладется по индексу
- При коллизиях создается связанный список (chaining), либо ищется свободная ячейка по какому-то алгоритму (open addressing)


# ==Парадигмы==

Подходы к описанию кода.

#### Императивное программирование

Описывает "Как надо делать?"
Описываешь последовательность действий:
```python
x = 5
y = 3
z = x + y
print(z)
```

Подтипы императивной:

- Процедурное программирование → функции/подпрограммы, структурированный код (C, Pascal).
- **Объектно-ориентированное (ООП)** → код организован вокруг объектов (Java, C++, Python).

#### Декларативное программирование

Описывает "Что нужно получить?"
Описывается результат, а не процесс.

Хороший пример: Flutter, CSS

Подтипы декларативного:

- **Функциональное** → результат выражается через функции, данные неизменяемы (Haskell, Scala, часть Python).
- **Логическое** → задаются факты и правила, а программа сама выводит результат (Prolog).



# ==ООП==

Объектно-ориентированное программирование - это парадигма программирования, основанная на концепции классов и объектов, и их взаимодействиях.

Назначение: разрабатывать поддерживаемые и расширяемые программы.

### Инкапсуляция

Инкапсуляция - принцип ООП, основанный на сокрытии классами своих данных и реализации и предоставление доступа к этим данным и поведению через публичные методы.

Назначение: классы должны быть независимы друг от друга.

Модульность как в ООП в Go реализуется через пакеты:
```go
package person

type Person struct {
	name string
	age int
}

func NewPerson(name string, age int) *Person {
	return &Person{name: name, age: age}
}

func (p *Person) SetAge(newAge int) {
	p.age = age
}

func (p *Person) GetName() string {
	return p.name
}
```

```go
package main

import ...

func main() {
	p := person.NewPerson("Tom", 10)
	
	p.SetAge(20)
	
	fmt.Println(p.GetName())
}
```

### Полиморфизм

Полиморфизм (многообразие) - принцип ООП, позволяющий работать с сущностями с одинаковыми интерфейсами **одинаково**, независимо от реализации сущностей.

Типы:

- Полиморфизм подтипов - использование объекта с одинаковыми интерфейсами, не зная реализацию объекта.

```go
package main

import "fmt"

// Интерфейс
type Shape interface {
    Area() float64
}

// Реализация интерфейса: Круг
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return 3.14 * c.Radius * c.Radius
}

// Реализация интерфейса: Прямоугольник
type Rectangle struct {
    Width, Height float64
}

func (r Rectangle) Area() float64 {
    return r.Width * r.Height
}

func printArea(s Shape) {
    fmt.Println("Area:", s.Area())
}

func main() {
    c := Circle{Radius: 5}
    r := Rectangle{Width: 4, Height: 6}

    printArea(c) // вызов через интерфейс
    printArea(r)
}
```

- Параметрический полиморфизм - выполнение логики в объекте, вне зависимости от переданного типа.

```go
package main

import "fmt"

// Универсальная функция для среза
func PrintSlice[T any](s []T) {
    for _, v := range s {
        fmt.Print(v, " ")
    }
    fmt.Println()
}

func main() {
    nums := []int{1, 2, 3}
    words := []string{"hello", "world"}

    PrintSlice(nums)   // int
    PrintSlice(words)  // string
}
```

- ad-hoc полиморфизм - основан на перегрузке методов, которые имеют одинаковое название и выполняются только по переданному типу.

В Go нет перегрузки методов как в Java/C++, но можно реализовать по-другому:
```go
package main

import "fmt"

func PrintValue(v interface{}) {
    switch val := v.(type) {
    case int:
        fmt.Println("int:", val)
    case string:
        fmt.Println("string:", val)
    default:
        fmt.Println("unknown type")
    }
}

func main() {
    PrintValue(10)
    PrintValue("hello")
}
```

### Наследование

Наследование -  принцип ООП, позволяющий одному классу наследовать свойства и поведение другого класса.

В Go наследование реализуется через композицию/агрегацию (композиция - внутренний класс не может существовать сам по себе, агрегация - может):
```run-go
package main

import (
	"fmt"
)

type Human struct {
	Name string
	Age int
}

func (h Human) SayMyName() {
	fmt.Println("My name is", h.Name)
}

func (h *Human) SetAge(age int) {
	h.Age = age
	fmt.Println("Set age is", h.Age)
}

type Action struct {
	Human
	ActionName string
}

func (a Action) DoAction() {
	fmt.Println("Do action:", a.ActionName)
}

func main() {
	action := Action{
		Human: Human{
			Name: "Bob",
			Age:  20,
		},
		ActionName: "sleep",
	}

	// вызов методов родительского Human у Action
	action.SayMyName() // композиция
	action.Human.SetAge(30) // агрегация

	action.DoAction()
}
```

### Абстракция

Абстракция - принцип ООП, направленный на сокрытие деталей реализации и предоставление абстракции (в Go через интерфейсы).

```go
package main

import "fmt"

// Интерфейс → абстракция
type Shape interface {
    Area() float64
}

// Реализация
type Circle struct {
    Radius float64
}

func (c Circle) Area() float64 {
    return 3.14 * c.Radius * c.Radius
}

func printArea(s Shape) {
    fmt.Println("Area:", s.Area())
}

func main() {
    c := Circle{Radius: 5}
    printArea(c) // работает через абстракцию Shape
}
```



# ==SOLID==

Пять принципов проектирования и написания кода в ООП.

S - single responsibility (принцип единственной ответственности)
O - open-closed (принцип открытости-закрытости)
L - Liskov substitution (принцип Барбары Лисков)
I - interface segregation (принцип разделения интерфейсов)
D - dependency inversion (принцип инверсии зависимостей)

### Single Responsibility

Каждый объект класса ответственен за выполнение определенной задачи и должен инкапсулировать эту логику внутри своего класса (Ссылается на принцип инкапсуляции).
анти-паттерн: God-obeject.

```run-go
package main

import (
	"fmt"
)

type Report struct {
	content string
}

func NewReport(data string) *Report {
	return &Report{content: data}
}

type Printer struct {}

func (p *Printer) print(data *Report) {
	fmt.Println("printed:", data.content)
}

func main() {
	p := &Printer{}
	
	r := NewReport("Отчет 112")
	
	p.print(r)
}
```

### Open-closed

Каждый класс (модуль, функция и т.д.) должен быть закрыт для изменений, но открыт для расширения. Классы могут менять свое поведение без изменения исходной реализации (Ссылается на принцип полиморфизма).

```go
type Shape interface {
    Area() float64
}

type Circle struct{ Radius float64 }
func (c Circle) Area() float64 { return 3.14 * c.Radius * c.Radius }

type Rectangle struct{ W, H float64 }
func (r Rectangle) Area() float64 { return r.W * r.H }

// Новые фигуры можно добавлять (ведь мы не зависим от Circle или Rect...)
func TotalArea(shapes []Shape) float64 {
    var sum float64
    for _, s := range shapes {
        sum += s.Area()
    }
    return sum
}
```

### Liskov Substitution

Функции, работающие с базовыми типами, должны уметь работать и с их подтипами, не зная об этом (Ссылается на принципы полиморфизма и наследования).

```go
type Bird interface {
    Eat() string
}

type FlyingBird interface {
    Bird
    Fly() string
}

type Sparrow struct{}
func (Sparrow) Eat() string { return "Sparrow eats" }
func (Sparrow) Fly() string { return "Sparrow flies" }

type Penguin struct{}
func (Penguin) Eat() string { return "Penguin eats" }
```

### Interface Segregation

Интерфейсы не должны быть перегружены большим числом методов (функционала). Их надо разделять на более специфичные задачи (Ссылается на принцип полиморфизма). 

```go
type Worker interface {
    Work()
}

type Eater interface {
    Eat()
}

type Human struct{}
func (Human) Work() {}
func (Human) Eat()  {}

type Robot struct{}
func (Robot) Work() {}
```

### Dependency Inversion

Абстракция не должна зависеть от реализации. То есть модули верхних уровней не должны быть зависимостями для модулей нижнего уровня (Ссылается на принцип абстракции). 

```go
// Абстракция
type UserRepository interface {
    GetUser(id int) string
}

// Конкретная реализация
type SQLUserRepository struct{}
func (SQLUserRepository) GetUser(id int) string { return "Alice" }

// Сервис зависит от интерфейса, а не от конкретной реализации
type UserService struct {
    Repo UserRepository
}

func (s UserService) GetUserName(id int) string {
    return s.Repo.GetUser(id)
}

// Handler зависит от сервиса
type UserHandler struct {
    Service UserService
}

func (h UserHandler) Handle(id int) {
    fmt.Println("User:", h.Service.GetUserName(id))
}

func main() {
    repo := SQLUserRepository{}
    service := UserService{Repo: repo}
    handler := UserHandler{Service: service}

    handler.Handle(1)
}
```

# ==Паттерны проектирования==

[ссылка](obsidian://open?vault=flutter_guide&file=Flutter%20Surf%20Intern%2Fzero-sprint%2F%D0%9E%D0%B1%D1%89%D0%B5%D0%B5%20-%20%D0%9F%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D1%8B%20(SI-11658))

# ==БД==

### Реляционная база данных

Реляционная БД - это база данных, в которой данные хранятся в вид таблиц (отношений), состоящих из строк (записей) и столбцов (полей).
Применяется строгая структура таблиц (схема) и ключи для связи между ними (первичные, внешние)

Язык для работы - SQL.
- DDL (Data Definition Language) - работа со структурой БД
- DML (Data Manipulation Language) - работа с данными
- DCL (Data Control Language) - работа с правами
- TCL (Transaction Control Language) - работа с транзакциями


**Примеры СУБД:** PostgreSQL, MySQL, Oracle, MS SQL Server.

### ACID

ACID - набор свойств для надежного исполнения транзакций.

A - Atomicity (атомарность) - транзакция либо выполняется полностью, либо не выполняется вообще.

C - Consistency (Согласованность) - транзакция переводит БД из одного согласованного состояния в другое (со всеми правилами и ограничениями).

I - Isolation (изоляция) - транзакция изолирована от других параллельных транзакций.

D - Durability (Долговечность) - после подтверждения транзакции данные не потеряются (даже при сбое).


### Нереляционные базы данных

Нереляционная БД - это база данных, не использующая традиционную структуру хранения данных. Она применяет различные модели хранения: документы (обычно JSON), графы, пары "ключ-значение" и т.д.

![[Pasted image 20250921174150.png]]

Применения:
- структура данных может меняться - документная БД (MongoDB)
- высокие нагрузки/постоянные запросы - ключ-значение (Redis), колонко-ориентированная (Cassandra)
- Множество связей (в соц.сетях, больших корпоративных системах и т.д.) - графовая (Neo4j) 
 

# ==HTTP и TCP/IP==

### HTTP

HTTP (HyperText Transfer Protocol) - протокол прикладного уровня, работающий поверх TCP/IP. Используется для передачи гипертекста (HTML, JSON, XML и т.д.) в сети Интернет.

- Общение через него происходит в форме "запрос-ответ". 
- Используются методы (GET, POST, PUT, DELETE и тд) для того, как обработать данные.
- Используются статус-коды для ответа.
- Использование заголовков для передачи метаинформации (информации о передаваемых данных).

![[Pasted image 20251010203925.png]]

![[Pasted image 20251010204008.png]]

### TCP/IP

TCP/IP - это сетевая модель и набор протоколов, которые задают правила для передачи информации в сети.

Она делится на уровни:

1. **Канальный уровень** — работа с физической сетью (Ethernet, Wi-Fi).
2. **Сетевой уровень** — доставка пакетов от узла к узлу (IP — Internet Protocol).
3. **Транспортный уровень** — доставка данных от приложения к приложению (TCP, UDP).
4. **Прикладной уровень** — протоколы приложений (HTTP, FTP, SMTP и т.д.).

TCP (Transmission Control Protocol) - это протокол транспортного уровня, отвечающий за гарантированную доставку пакетов и контроль ошибок. 

UDP (User Datagram Protocol) - это тоже транспортный протокол, но он работает быстрее TCP за счет отсутствия гарантий доставки и порядка.

Используется в:
- Стриминг (видео, аудио).
- Онлайн-игры.
- VoIP (звонки).
- DNS-запросы (т.к. можно узнать IP домена нужен один пакет).

![[Pasted image 20251010204304.png]]

# ==REST==

REST (Representational State Transfer) - это архитектурный стиль построения веб-сервисов, поверх HTTP.

6 принципов REST API:
1. Клиент-серверная модель (четкое разделение клиента и сервера)
2. Отсутствие состояния (сервер не хранит состояние, каждый новый запрос от клиента заново обрабатывается сервером)
3. Кэширование (частые одинаковые запросы могут быть добавлены в кэш)
4. Единый интерфейс (при запросе на один и тот же ресурс приходит такая же информация с допустимыми функциями (можно изменять, удалять, читать))
5. Многоуровневая система - между клиентом и сервером могут быть промежуточные узлы (тот же Nginx): middlewares, прокси-сервера и т.д.
6. Код по требованию (code on demand) - сервер может отправить в ответ на запрос исходный код, который будет исполняться на клиенте. Можно передавать целые сценарии.