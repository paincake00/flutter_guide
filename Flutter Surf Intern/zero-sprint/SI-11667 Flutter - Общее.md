
Source 1: [статья](https://www.purrweb.com/ru/blog/razrabotka-na-flutter-plyusi-minusi/)
Source 2: https://docs.flutter.dev/resources/architectural-overview
#### Что такое Flutter и зачем был создан

Flutter — популярный кроссплатформенный фреймворк для разработки приложений. Компания Google создала набор инструментов с открытым исходным кодом, чтобы разработчики могли создавать приложения для iOS, Android, Windows, Mac, Linux и Web.

#### Эволюция Flutter

![[Pasted image 20250109202411.png|600]]

**2015**: Появляется Sky, который был направлен на достижение высокой производительности и качества рендеринга. Он стал основой для Flutter.

**Май 2017**: Flutter был впервые представлен на конференции разработчиков Google I/O.

**Декабрь 2018**: Google объявил о выпуске Flutter 1.0. Фреймворк сильно продвинулся и перешел на модель опенсорс.

**Март 2021**: Flutter 2.0. Пожалуй, самым значительным нововведением стала поддержка десктопных и веб-приложений.

**Февраль 2022**: выпустили Flutter 3.0. В это время в Dart появилась новая функция - нулевая безопасность.

#### Преимущества Flutter

- ==Скорость разработки==: декларативный подход создания интерфейса с помощью виджетов значительно ускоряет разработку приложения.
- ==Кроссплатформенность==: это позволяет создавать приложения, похожие на нативные, сразу под разные платформы. Это не только оптимизирует разработку, но и значительно сокращает расходы.
- ==Высокая производительность==: Та самая вещь, которая будет радовать пользователей и злить конкурентов (в лице того же React Native).
- ==Сообщество и поддержка==: Развитие технологии и добавление новых библиотек от разработчиков.

#### Недостатки Flutter

- ==Нельзя встроить нативные функции==: Нет доступа к нативному коду. Может потребоваться использовать родной код, например, при работе с tvOS, watchOS, Android Auto или CarPlay.
- ==Сверхвысокие требования к производительности==: Для приложений с критически важной производительностью нативная разработка может обеспечить необходимое преимущество в скорости (например, финансовая торговля, где должны быть обновления в реальном времени).

#### Архитектурные слои фреймворка

![[Pasted image 20250109212752.png|600]]
- Слой Framework предоставляет API высокого уровня разработчикам для создания приложения на основе виджетов. 
- Слой Engine отвечает за растеризацию компонентов UI для каждого нового кадра. Он отвечает за низкоуровневую реализацию Flutter API для работы с графикой, файловым и сетевым вводом-выводом, инструментарий для компиляции на Dart. 
- Слой Embedder работает с нативными функциями конкретной платформы, которые предоставляются самой операционной системой устройства.

#### Три дерева

Есть три дерева, отвечающие за отображение UI на экране, который был задан разработчиком через структуру из виджетов:
- Widget Tree
- Element Tree
- RenderObject Tree

![[Pasted image 20250109224659.png]]

- `Widget Tree` состоит из `Widget`, которые используются для описания пользовательского интерфейса
- `Element Tree` состоит из `Element`, которые управляют жизненным циклом виджета, содержат информацию об иерархии, и связывают виджеты и объекты рендеринга.
- `Render Tree` состоит из `RenderObject`, которые используются для определения размеров, положения, геометрии, определения зон экрана, на которые могут повлиять жесты.

#### Инициализация деревьев и их объектов

Имеем пример кода:

```dart
Container(
  color: Colors.blue,
  child: Row(
    children: [
      Image.network('https://www.example.com/1.png'),
      const Text('A'),
    ],
  ),
);
```

1) Сначала вызывается метод `build()`, который добавляет данное поддерево в существующее дерево виджетов. В процессе могут создаваться дополнительные виджеты в зависимости от указанных данных.
2) На этапе сборки Flutter переводит дерево виджетов, выраженные в коде, в дерево элементов, соответственно. Есть два типа элементов: ComponentElement (хост, состоящий из других элементов) и RenderObjectElement (посредник между виджетом и конкретным объектом отображения, который будет наследоваться от RenderObject). Дерево элементов отвечает именно за изначальное расположение (иерархию) виджетов в дереве, поэтому при обновлении состояния оно не должно постоянно перестраиваться, что обеспечивает высокую производительность. К элементу можно обращаться через BuildContext.
3) RenderObject определяет абстрактную модель для размещения и отрисовки конкретно на экране. То есть для каждого элемента из дерева элементов, Flutter создает и обновляет объект, наследуемый от RenderObject (а конкретно от RenderBox, который является RenderObject с фиксированными размерами). Например, RenderObject имеет примитивы: RenderParagraph - отрисовывает текст, RenderImage - отрисовывает изображение, а RenderTransform - применяет трансформацию перед отрисовкой своего ребенка.
4) После этого прохода по дереву, объекты получают свои размеры в соответствии с ограничениями (constraints) своих родителей. И теперь они готовы к отрисовке через метод `paint()`.