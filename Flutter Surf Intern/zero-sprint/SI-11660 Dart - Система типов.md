
### **Различия между статической и динамической, строгой и нестрогой типизацией языков программирования**

- Статическая типизация: типы переменных определяются на этапе компиляции, а не во время выполнения. Это означает, что компилятор проверяет типы переменных перед запуском программы.
- Динамическая типизация: типы переменных определяются во время выполнения, а не на этапе компиляции.
- Строгая типизация: язык требует явного указания типов переменных и проверяет их на этапе компиляции.
- Нестрогая типизация: язык не требует явного указания типов переменных и не проверяет их на этапе компиляции.

### **Типизация языка Dart**

Dart является языком со статической и строгой типизацией. Это означает, что типы переменных определяются на этапе компиляции, и компилятор проверяет их на этапе компиляции.

```dart
int x = 5; // тип int определяется явно
String y = 'hello'; // тип String определяется явно
```

В Dart нет "простых" типов, таких как int, double, bool, потому что все типы являются объектами и наследуются от класса Object. Это означает, что все типы имеют методы и свойства, которые можно использовать.

```dart
int x = 5;
print(x.runtimeType); // выводит "int"
print(x is Object); // выводит "true"
```

### **Разница между var/final/const**

- var: переменная, тип которой определяется компилятором на основе присвоенного ей значения.
- final: переменная, значение которой не может быть изменено после ее инициализации.
- const: переменная, значение которой известно на этапе компиляции и не может быть изменено.

```dart
var x = 5; // тип int определяется компилятором
final y = 5; // значение не может быть изменено
const z = 5; // значение известно на этапе компиляции
```

### **late модификатор**

late модификатор позволяет объявить переменную без инициализации, но с обязательной инициализацией перед ее использованием.

### **dynamic**

dynamic позволяет объявить переменную без указания ее типа, что позволяет ей принимать любые значения. В отличие от var дает доступ переменной менять свое значение несколько раз.

```dart
dynamic x = 5;
x = 'hello'; // тип String
x = true; // тип bool
```

dynamic стоит использовать, когда необходимо работать с данными неизвестного типа, или когда необходимо написать код, который работает с любыми типами данных.

dynamic не стоит использовать, когда тип данных известен, потому что это может привести к ошибкам во время выполнения.

#### Отличие от Object

- В отличие от `dynamic`, при использовании `Object` вы должны явно приводить тип (через `as`), если вы хотите взаимодействовать с конкретными методами и свойствами.
- Т.к. проверки типов у dynamic происходят во время выполнения, то Object более производительный в этом плане

```dart
dynamic dynamicVar = 'Hello, Dart!';
print(dynamicVar.length); // Работает, так как это строка

dynamicVar = 42; // Теперь это int
// print(dynamicVar.length); // Ошибка во время выполнения

Object objectVar = 'Hello, Dart!';
print((objectVar as String).length); // Явное приведение типа

objectVar = 42; // Теперь это int
// print((objectVar as String).length); // Ошибка времени выполнения
```

### Type inference

Принцип type inference позволяет компилятору определять тип переменной на основе присвоенного ей значения.

```dart
Map<String, dynamic> arguments = {'argA': 'hello', 'argB': 42};
```

Альтернативно:

```dart
var arguments = {'argA': 'hello', 'argB': 42}; // Map<String, Object>
```

Использование type inference может привести к неожиданным багам, когда тип переменной не соответствует ожидаемому типу, или когда переменная используется в контексте, где ожидается другой тип:

```dart
var x = 5; // тип int определяется компилятором
print(x is String); // выводит "false", но ожидается "true"
```

#### **Type Inference с Generic**

Type inference с generic в Dart работает следующим образом:

- Когда вы объявляете generic класс или функцию, вы можете не указывать типы параметров явно.
- Dart будет пытаться вывести типы параметров на основе контекста, в котором они используются.
- Если Dart не может вывести типы параметров, он будет использовать тип `dynamic` по умолчанию.

```dart
class Container<T> {
  T value;

  Container(this.value);
}

void main() {
  var container = Container(42); // T будет выведен как int
  print(container.value); // выводит 42

  var container2 = Container('hello'); // T будет выведен как String
  print(container2.value); // выводит 'hello'
}
```

