
Source: https://dart.dev/null-safety/understanding-null-safety

### **Зачем языку нужна концепция null?**

Концепция null необходима для того, чтобы указать, что переменная или свойство не содержит никакого значения. Это позволяет избежать ошибок, связанных с обращением к несуществующим значениям, и делает код более безопасным и предсказуемым.

### **Почему Dart решил поменять подход работы с null и перейти на nullSafety?**

До появления nullSafety в Dart, null был частью типа каждого объекта. Это означало, что любая переменная или свойство могли содержать null, даже если это не было явно указано. Это приводило к ошибкам, связанным с null, которые были трудно обнаружить и исправить.

NullSafety в Dart был введен для решения этой проблемы. Теперь типы в Dart делятся на nullable и non-nullable.

#### Принципы Null Safety

- Non-nullable by default: по умолчанию тип данных не является нулевым.
- Fully sound: полностью безопасен. Типы данных указанные как не нулевые, НИКОГДА не будут принимать нулевое значение. Это объявление типа также оптимизирует работу компилятора.

### **Null как тип и его место в иерархии типов**

Null - это тип, который представляет отсутствие значения (Допускает только тип объекта null).

![[Pasted image 20250120134740.png|400]]

До Null Safety (по концепции null) в Dart тип Null был подтипом всех типов. Но с появлением нулевой безопасности иерархия изменилась: 

![[Pasted image 20250120134756.png|400]]

Теперь по умолчанию все типы ненулевые (то есть, не допускают null). Что предостерегает от ошибок, связанных с отсутствием данных.

Но часто бывает, что надо указать что тип может содержать объект null, поэтому мы задаем ему тип nullable через `?` (например, `String?`). Мы с полной безопасностью можем вызвать ТОЛЬКО следующие операторы и методы для объекта nullable типа: `toString`, `==` и `hashCode`.

Иерархия теперь такая:

![[Pasted image 20250120140725.png|400]]

В системе Dart должны быть верхний и нижний типы (top type and bottom type). Это `Object?` и  `Never`, соответственно. Вот такая иерархия теперь:

![[Pasted image 20250120143046.png|400]]

Тип Never может например использоваться в коде, в котором не ожидается какого-то успешного завершения с возвратом значения. Допустим, исключение. Вот пример метода:

```dart
// Using null safety:
Never wrongType(String type, Object value) {
  throw ArgumentError('Expected $type, but was ${value.runtimeType}.');
}
```

Он может быть применен в коде:

```dart
// Using null safety:
class Point {
  final double x, y;

  bool operator ==(Object other) {
    if (other is! Point) wrongType('Point', other);
    return x == other.x && y == other.y;
  }

  // Constructor and hashCode...
}
```

То есть, при ошибке не будет какого-либо возврата значения вообще. И даже несмотря на то, что other тип Object, у него вызываются поля как у объекта типа Point. Т.к. этот код может быть выполнен, если первое утверждение неверно. Dart это продвигает.

#### Почему не использовать void вместо Never?

Есть некоторые отличия у этих типов. На примере функции foo():

Void foo() {}: Функция, которая обычно возвращается нормально, но не возвращает (значимый) результат

Never foo() {}: функция, которая возвращается ненормально (например, бросает или запускает бесконечный цикл), например, функция exit().

Другими словами, использование Never в ваших собственных API позволяет расширить анализ доступности Dart.

### **Сравнение типов/объектов Null, null, Never, void**

- Null - это тип, который представляет отсутствие значения (Допускает только тип объекта null).
- null - это объект, который является единственным экземпляром типа Null.
- Never - это тип, который представляет значение, которое никогда не будет возвращено (например, намеренно выбросится ошибка).
- void - это тип, который представляет отсутствие значения, но не является типом Null (Тип void допускает значения любого типа, но сообщает, что значение не должно использоваться.).