
Source: https://surf.ru/cases/biblioteka-elementary/

Elementary - библиотека, которая предоставляет механизмы для написания приложения по правилам Clean Architecture с разделением модулей на блоки. Это реализация [Model-View-ViewModel (MVVM)](https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm#the-mvvm-pattern) паттерна для Flutter приложений.

### ElementaryModel

ElementaryModel соответствует слою Model в MVVM. Обычно мы заключаем в неё всю работу с бизнес-логикой, которая требуется конкретному компоненту. Это значит, что все бизнесовые зависимости нужно поставить в модель и использовать их для достижения целей бизнес-логики именно в ней (при инициализации экземпляра можно передать репозиторий или UseCase, например).

### WidgetModel

Сущность WidgetModel соответствует ViewModel в концепте MVVM. Как и в MVVM, WidgetModel является адаптером состояния модели. Значит, ElementaryModel — это прямая зависимость WidgetModel, которая позволит получить связь с бизнес-логикой. Это единственная точка входа презентационной логики в бизнесовую.

WidgetModel является тем местом, где необходимо инкапсулировать всю презентационную логику.

### ElementaryWidget

ElementaryWidget является слоем представления и соответствует View в MVVM концепте. Во Flutter один из типов виджетов — компоновочные виджеты: например, Stateless и Stateful виджеты. Сами по себе они ничего не отображают, а лишь берут и, как конструктор, собирают отображение из других. ElementaryWidget тоже компоновочный.

Чтобы компоновочные виджеты могли понимать, где именно выстраивать свою часть поддерева, им обычно передаётся BuildContext. 

Единственным источником данных, опираясь на концепт MVVM, становится WidgetModel.


### Element

Чтобы всё работало корректно, необходим механизм, который обеспечит связь всех слоёв. Element во Flutter нужен как раз для этого.

**Element:**

- отвечает за хранение WidgetModel; 
- обеспечивает её работоспособность, организуя работу жизненного цикла;
- предоставляет её виджету в виде контракта, чтобы тот мог представить отображение.

В результате вместе с элементом устройство каждой связки выглядит примерно так:

![[Pasted image 20241225231826.png]]


### Обработка ошибок

Для централизованной обработки всех ошибок ElementaryModel принимает специальную сущность ErrorHandler. В ней можно реализовать логирование и любую другую бизнесовую обработку произошедшей ошибки. О произошедшей ошибке мы также сообщим WidgetModel, чтобы была возможность обработать её с точки зрения пользователя: например, показать снэкбар — небольшое сообщение в верхней части интерфейса, которое несёт фидбэк в ответ на только что выполненное действие.

У WidgetModel для этого существует специальный метод жизненного цикла — onErrorHandle. Весь механизм обработки внутри модели запускается вызовом handleError.

### Тестирование 

**ElementaryModel** покрывается [unit-тестами](https://habr.com/ru/company/surfstudio/blog/653755/), которые проверяют конкретный модуль системы. Здесь всё довольно просто: бизнесовые зависимости поставляются классу, их можно замокировать — то есть отправлять запросы не на реальный сервер, а на «заглушку».

**ElementaryWidget** можно проверить с помощью Widget и Golden-тестов. Процесс тестирования становится даже проще, чем в стандартном подходе Flutter: единственный источник данных для этого виджета — WidgetModel, представленная в виде интерфейса из свойств, а сам по себе виджет — лишь обёртка над поддеревом.

Тестирование **WidgetModel** изначально не было таким простым. Мы должны проверить, что при определённых условиях WidgetModel поставляет свойства в том виде, в котором мы и ожидали. Но готового механизма для удобного тестирования не было: тесты получались довольно многословными. 

Для этого мы написали библиотеку [elementary test](https://pub.dev/packages/elementary_test). Она берёт на себя всю имитацию программной части, а наружу предоставляет «пульт управления» происходящими процессами. Теперь тестировать WidgetModel просто.