
Пакет - предоставляет удобную организацию разделения кода на отдельные части. 
По сути, это просто каталог/папка, которая содержит файлы исходного кода.

Импортируя пакет, мы можем использовать многократно использовать код в нем в различных программах.

Код пакета может располагаться в одном или нескольких файлах с расширением `go`. Обозначить пакет можно с помощью ключевого слова `package`.

Вот пакет `main`:
```go
package main
import "fmt"

func main() {
	...
}
```

Есть два типа пакетов:
- исполняемые (executable)
- библиотеки (reusable)

Для создания исполняемых файлов пакет должен называться `main` и должна быть соответственно функция `main`. Все остальные пакеты не являются исполняемыми.

### Импорт пакетов

Если надо импортировать готовые пакеты с необходимой функциональностью, то используется оператор `import`:
```go
package main
import "fmt"
import "math"

func main() {
	fmt.Println(math.Pow(2, 8))
} 
```

Также импортируемые пакеты можно объединить с помощью скобок:
```go
import (
	"fmt"
	"math"
)
```

Если временно не используем пакет, то можно прописать `_` (чтобы не ругался компилятор):
```run-go
package main
import "fmt"
import _ "math"

func main() {
	fmt.Println(". . .")
}
```

### Приоритет поиска пакетов в Go

1. **Текущая папка** (или относительный путь): при импорте пакета с помощью относительного пути Go сначала будет искать его в текущем каталоге проекта (модуле), где находится компилируемый файл.
2. **Путь GOROOT/src**: здесь Go ищет пакеты, которые являются частью стандартной библиотеки Go, например, `fmt`, `net/http`, `os` и т.д. Посмотреть значение переменной можно через `go env GOROOT`.
3. **Папка vendor**: если внутри проекта существует данная папка, то Go ищет все остальные пакеты там. Создается через `go mod vendor` и используется для хранения сторонних пакетов.
4. **Локальный кеш модулей**: если папка `vendor` отсутствует, Go ищет пакеты в кеше модулей, который расположен по пути, задаваемой переменной **$GOMODCACHE** (посмотреть через `go env GOMODCACHE`).
5. **Удаленные репозитории**: если пакета нет в кеше, Go скачивает его на основе информации из файла конфигурации модуля **go.mod**, который создается для текущего проекта.

### Несколько файлов в одном пакете

Определим файлы `main.go` и `hello.go`:
```go
package main
import "fmt"

func sayHello() {
	fmt.Println("Hello")
}
```

```go
package main

func main() {
	sayHello()
}
```

Теперь запустим нашу программу из двух файлов. Для этого компилятору надо передать все файлы нашего проекта:
```sh
go run main.go hello.go
```

Аналогично при сборке проекта в исполняемый файл также передаются все файлы проекта (Флаг -o указывает, как будет называться выходной файл - в данном случае app):
```sh
go build -o app main.go hello.go
```

И запуск:
```sh
./app
```

